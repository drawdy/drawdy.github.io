<!doctype html><html lang=zh-cn><head><meta charset=utf-8><title>Kubernetes API Server 从入门到入库（上） - 天行健 君子以自强不息</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=generator content="Hugo 0.84.0"><meta property="og:site_name" content="天行健 君子以自强不息"><meta property="og:title" content="Kubernetes API Server 从入门到入库（上）"><meta property="og:description" content="一个以计算机技术分享为主的博客，重点关注云原生、DevOps、AI 领域。除了严肃理性的分析，还会有记录生活、感悟人生的随笔。"><meta property="description" content="一个以计算机技术分享为主的博客，重点关注云原生、DevOps、AI 领域。除了严肃理性的分析，还会有记录生活、感悟人生的随笔。"><meta property="og:url" content="https://blog.pearlfisher.xyz/blog/kube-apiserver-1/"><meta property="og:type" content="article"><meta property="og:image" content="https://blog.pearlfisher.xyz/img/main/logo.jpg"><link rel=stylesheet href=/css/bundle.min.6ad9eb85bff384c75937a02036b01425a2ca63f19a96535b8ba5b181db62a4b3.css integrity="sha256-atnrhb/zhMdZN6AgNrAUJaLKY/GallNbi6WxgdtipLM="><link rel=stylesheet href=/css/add-on.css></head><body><header id=site-header><nav id=site-nav><h1 class=nav-title><a href=/ class=nav>博客</a></h1><menu id=site-nav-menu class="flyout-menu menu"><a href=#search-input class="nav link search-toggle"><i class="fas fa-search">&nbsp;</i>Search</a></menu>
<a href=#search-input class="nav search-toggle"><i class="fas fa-search fa-2x">&nbsp;</i></a>
<a href=#site-nav class="nav nav-toggle"><i class="fas fa-bars fa-2x"></i></a></nav><menu id=search class=menu><input id=search-input class="search-input menu"></input><div id=search-results class="search-results menu"></div></menu></header><div id=wrapper><section id=site-intro><a href=/><img src=https://blog.pearlfisher.xyz/img/main/logo.jpg class=circle width=100px alt></a><header><h1>采珠人</h1></header><main><p>一个以计算机技术分享为主的博客，重点关注云原生、DevOps、AI 领域。</p></main><footer><ul class=socnet-icons><li><a href=//github.com/drawdy/blog target=_blank rel=noopener title=GitHub class="fab fa-github"></a></li><li><a href=mailto:drawdy2010@hotmail.com target=_blank title=Email class="far fa-envelope"></a></li></ul></footer></section><main id=site-main><article><div class=post><header><div class=title><h2><a href=/blog/kube-apiserver-1/>Kubernetes API Server 从入门到入库（上）</a></h2></div><div class=meta><time datetime="2021-06-13 23:07:51 +0800 +0800">June 13, 2021</time><p>3 分钟</p></div></header><div id=socnet-share></div><div class=content><p>Kubernetes API Server 负责验证和配置 Kubernetes API对象，提供了 RESTful API供用户和其他组件与 Kubernetes 交互。Kubernetes API Server 源码编译出的程序为 kube-apiserver，本质上是一个 HTTP 服务器程序，使用 go 语言提供的 http 库可以很方便的创建并运行。如下面的代码所示，监听地址（Addr）和处理方法（Handler）是创建 HTTP 服务必要的参数。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>server</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Server</span>:{
  <span style=color:#a6e22e>Addr</span>: <span style=color:#a6e22e>addr</span>,
  <span style=color:#a6e22e>Handler</span>: <span style=color:#a6e22e>handler</span>,
}
</code></pre></div><p>Addr 是 TCP 协议地址，格式为<code>host:port</code>。port 表示端口，值为 1~ 65535 范围内的整数，其中 1 ~ 1023 是保留端口，不可以随便使用，用户可以从 1024 ~ 65535 中选取任意一个没有被占用的数作为端口。 host 可以是 IP， 也可以是能够解析为 IP 的主机名。host 为 IP 时有三种情况：为回环地址（127.0.0.1）时，只能在本地通过 127.0.0.1 加端口访问服务；为 0.0.0.0 或者直接省略 host 只保留<code>:port</code>时，表示监听本机的所有 IP，从网络可达的其他主机上通过任何本机 IP加端口都可以访问服务；最常见的是指定为某个固定的 IP，如 192.168.1.10，表示可以通过该 IP 加端口访问到服务。</p><p>Handler 是 HTTP 服务器程序的核心，是处理请求、返回响应的过程。HTTP 服务器通常会对多个路径提供服务，每个路径都对应一个 Handler，最外层的 Handler 通常称为路由器，负责解析请求消息，找到并调用路径对应的 Handler。</p><p>Kubernetes 发展速度非常快，目前的代码量已经有四五百万行，作为 Kubernetes 的入口，kube-apiserver 几乎涉及每个功能，完全理解需要对 Kubernetes 的相关概念很熟悉。另外，为了获得更好的高扩展性、低耦合度、高代码复用率，社区开发人员应用大量框架优化架构，这导致阅读源码不太容易。本文结合源码对 Kubernetes API Server 运行流程、架构原理加以说明，希望对你有所帮助。</p><h2 id=1-启动过程>1 启动过程</h2><p>阅读源码最好先从最外层方法看起，遇到调用的子方法，先大概了解子方法的功能作用，不宜最开始就深入到最内层，等外层方法的过程明白了主要功能作用，再进入到子方法看细节。kube-apiserver 程序入口在 Kubernetes 代码仓库<code>cmd/kube-apiserver/apiserver.go</code>文件。如下图所示，从整体上看，kube-apiserver 的启动过程包括了解析命令行参数、创建服务配置、创建聚合服务器、启动服务器几个步骤，其中创建聚合服务器最为复杂，包括创建扩展资源服务、配置 Handler、创建聚合 API 服务器等步骤，每个步骤深入进去会发现调用了很多子方法。下面就具体看下过程中重要步骤的细节。</p><div align=center><img src=/img/kube-apiserver/kube-apiserver-start-process.png>
<center>kube-apiserver 启动过程</center></div><h2 id=2-解析命令行参数>2 解析命令行参数</h2><p>kube-apiserver 最外层是使用 cobra 框架创建的 CLI 程序，从命令行接收参数，供后续创建服务器时使用。<code>cmd/kube-apiserver/app/server.go</code>文件中的 NewAPIServerCommand() 方法是创建 cobra.Command 的过程。cobra.Command 中的 Run 或 RunE 属性是命令行执行时调用的方法，其调用的 options.NewServerRunOptions() 子方法初始化主要的命令行参数，这些参数可以配置服务器、Etcd、Audit、Admission 等模块。这部分代码比较简单直观，不展开讲。</p><h2 id=3-创建服务配置>3 创建服务配置</h2><p>kube-apiserver 中的 Server 创建过程遵循统一的模式，即先初始化配置，再通过配置实例化 Server 对象。在初始化命令行参数后，程序调用 CreateServerChain() 子方法实例化服务器对象，进入到该子方法可以看到其调用 CreateKubeAPIServerConfig() 方法来初始化配置。方法返回的配置是 kube-apiserver 的基础通用配置，后续过程会在此基础上补充新的配置，以创建其他业务对象。</p><p>服务配置覆盖的内容非常多，有些不太常用的条目,我也不确定具体作用，现对常用到配置项做出说明，以帮助理解。</p><p><code>genericConfig</code> 通用配置，包含了很多方面的内容，像认证鉴权方法、CORS 源、准入控制、是否开启路径索引、是否开启服务启动后回调钩子等，还有一部分内容主要服务于程序后续流程，跟用户自定义关系不大，如序列化组件、健康检测器、构建 handler 链的方法等。</p><p><code>versionedInformers</code> 内置资源的 Informer，优化外部通过 kube-apiserver 操作资源的操作。Informer 可以理解为客户端请求 API 资源过程中的优化组件，使用内存队列缓存客户端监听的资源，有着优秀的架构设计，对 kube-apiserver 启动过程影响不大，本文不做过多说明。</p><p><code>serviceResolver</code> 可以将对服务的请求转化为具体的 URL，即解析为服务对应的 Endpoint。</p><p><code>pluginInitializers</code> 服务于准入控制（admission）模块，准入控制插件会实现对应的接口以表达自己需要被注入的依赖数据，pluginInitializers 负责检测插件实现了哪些接口并注入相应的数据。</p><p><code>admissionPostStartHook</code> 准入控制执行完后的回调钩子。</p><p><code>storageFactory</code> 是创建 API 资源存储接口的组件。Kubernetes 的所有数据都存储在 Etcd 中，各 API 资源的存储逻辑是相似的。storageFactory 中包括了 Etcd 相关属性，默认的序列化器、API 资源组路径前缀等。</p><p><code>capabilities</code> 是对操作系统支撑能力的表示，如特权模式相关配置等。</p><h2 id=4-三种类型的-api-server>4 三种类型的 API Server</h2><p>从 CreateServerChain() 这个方法名可以看出，程序创建的是包含多个<code>server</code>的服务器链，准确的说是三个，即 APIExtentionsServer、KubeAPIServer 和 AggregatorServer。APIExtentionsServer 用于管理自定义资源等扩展 API，定义了处理 CustomResourceDefinition 对象的 handler。KubeAPIServer 用于管理内置资源，包括传统资源（LegacyAPI，如 Pod、Service、ConfigMap）和常规资源（路径前缀为 <code>/apis</code>，如 Deployment、StorageClass、ClusterRole）,传统资源是 Kubernetes 早期创建的内置资源，没有隶属的组（Group），路径前缀为<code>/api</code>。AggregatorServer 则是一种特殊类型的 API Server，相对于安装集群时部署 kube-apiserver 组件，这里的 API Server 的含义已经发生了变化，是之逻辑上自成一体的服务模块，这样的服务可以有很多个，像上面的 APIExtentionsServer 和 KubeAPIServer 都是这种概念，这些服务在 Kuberenetes中被描述成 APIService 资源。 AggregatorServer 创建控制器自动收集集群中的 APIService 资源，自动注册到反向代理服务器，用户独立开发的 API Server 通过这种方式集成到 Kubernetes，不用将代码合并到主库。</p><p>实际上，这三个 Server 只是逻辑上的划分，各自有业务上相对独立的 Handler，区别开来可以更好的封装和解耦，最终创建出来的 HTTP Server 只有一个。那么这些 Server 是怎么关联起来的呢？观察三个 Server 的创建方法，会发现每个都有一个 DelegationTarget 参数，新创建的的 Server 会将该参数作为属性引用。其实，DelegationTarget 是对 API Server 的抽象，如果当前 Server 无法处理请求就委托给关联的 DelegationTarget 处理。这些 Server 在结构上组成一个<code>单向链表</code>，每个 Server 都是其中的节点，如下图所示。</p><div align=center><img src=/img/kube-apiserver/kube-apiserver-chain.png>
<center>kube-apiserver 服务链</center></div><h2 id=5-启动服务器>5 启动服务器</h2><p>如下面的代码所示，在创建完 server 链后，程序执行 server.PrepareRun() 方法做准备工作，主要有两部分内容，一是注册 readyz、livez 等状态检测 API，还有是注册启动后、退出前的回调方法。PrepareRun 会以递归的方式调用 API Server 链上每个 Server 的 PrepareRun 方法。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Run</span>(<span style=color:#a6e22e>completeOptions</span> <span style=color:#a6e22e>completedServerRunOptions</span>, <span style=color:#a6e22e>stopCh</span> <span style=color:#f92672>&lt;-</span><span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>struct</span>{}) <span style=color:#66d9ef>error</span> {
	<span style=color:#75715e>// To help debugging, immediately log version
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>klog</span>.<span style=color:#a6e22e>Infof</span>(<span style=color:#e6db74>&#34;Version: %+v&#34;</span>, <span style=color:#a6e22e>version</span>.<span style=color:#a6e22e>Get</span>())

	<span style=color:#a6e22e>server</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>CreateServerChain</span>(<span style=color:#a6e22e>completeOptions</span>, <span style=color:#a6e22e>stopCh</span>)
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
	}

	<span style=color:#a6e22e>prepared</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>server</span>.<span style=color:#a6e22e>PrepareRun</span>()
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
	}

	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>prepared</span>.<span style=color:#a6e22e>Run</span>(<span style=color:#a6e22e>stopCh</span>)
}
</code></pre></div><p>准备工作完成后，服务开始启动，最终会调用 Golang 的库方法 http.server.Serve() 启动 HTTP 服务。</p><h2 id=6-go-restful-框架>6 go-restful 框架</h2><p>kube-apiserver 使用 go-restful 框架配置 Handler，该框架有三个核心概念：</p><p><code>Route</code> 表示一条路由，包含请求路径、请求方法及对应的 Handler，框架内置的路由选择器根据 Route 配置将客户端的请求路由到相应的 Handler 进行处理；</p><p><code>WebService</code> 表示一组 API 集合，由多个 Route 组成。WebService 中的 Route 具有相同的 root path，一致的请求数据类型，一般是相关性非常强的 API。</p><p><code>Container</code> 表示一个服务器，由多个 WebService 组成，包含一个 dispatch 方法，负责将 Container 接收的请求分发给持有的 WebService，再由 WebService 分发给具体的 Handler。</p><p>在使用框架时，开发人员需要创建 Container 实例，并添加 WebService 和 Route，再提交给 http.Server 作为 Handler 使用。Container 其实就是最外层的 HTTP 请求处理方法。上述三者的关系如下图所示。</p><div align=center><img src=/img/kube-apiserver/go-restful-cwr.png>
<center>Route、WebService 和 Container 关系</center></div><h2 id=7-各server-handler-联系>7 各server handler 联系</h2><p>上一节中说到，三个 API Server 组成一个<code>链表</code>，后创建的 Server 引用前一个，DelegationTarget 作为 Server 的抽象接口被持有。如下面的代码所示， Server 在创建时会将 DelegationTarget.UnprotectedHandler() 即持有的上一个 Server 的 Handler 作为 notFoundHandler 添加到当前 Server 的Container。这样达到的效果是，当前 Server 匹配不到的请求路径时会交由持有的上一个 Server 处理，三个 Server 的 Handler 也形成了<code>链表</code>的关系。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>NewAPIServerHandler</span>(<span style=color:#a6e22e>name</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>s</span> <span style=color:#a6e22e>runtime</span>.<span style=color:#a6e22e>NegotiatedSerializer</span>, <span style=color:#a6e22e>handlerChainBuilder</span> <span style=color:#a6e22e>HandlerChainBuilderFn</span>, <span style=color:#a6e22e>notFoundHandler</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Handler</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>APIServerHandler</span> {
	<span style=color:#a6e22e>nonGoRestfulMux</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>mux</span>.<span style=color:#a6e22e>NewPathRecorderMux</span>(<span style=color:#a6e22e>name</span>)
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>notFoundHandler</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#a6e22e>nonGoRestfulMux</span>.<span style=color:#a6e22e>NotFoundHandler</span>(<span style=color:#a6e22e>notFoundHandler</span>)
	}

	<span style=color:#a6e22e>gorestfulContainer</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>restful</span>.<span style=color:#a6e22e>NewContainer</span>()
	<span style=color:#a6e22e>gorestfulContainer</span>.<span style=color:#a6e22e>ServeMux</span> = <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>NewServeMux</span>()
	<span style=color:#a6e22e>gorestfulContainer</span>.<span style=color:#a6e22e>Router</span>(<span style=color:#a6e22e>restful</span>.<span style=color:#a6e22e>CurlyRouter</span>{}) 
	<span style=color:#a6e22e>gorestfulContainer</span>.<span style=color:#a6e22e>RecoverHandler</span>(<span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>panicReason</span> <span style=color:#66d9ef>interface</span>{}, <span style=color:#a6e22e>httpWriter</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>) {
		<span style=color:#a6e22e>logStackOnRecover</span>(<span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>panicReason</span>, <span style=color:#a6e22e>httpWriter</span>)
	})
	<span style=color:#a6e22e>gorestfulContainer</span>.<span style=color:#a6e22e>ServiceErrorHandler</span>(<span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>serviceErr</span> <span style=color:#a6e22e>restful</span>.<span style=color:#a6e22e>ServiceError</span>, <span style=color:#a6e22e>request</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>restful</span>.<span style=color:#a6e22e>Request</span>, <span style=color:#a6e22e>response</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>restful</span>.<span style=color:#a6e22e>Response</span>) {
		<span style=color:#a6e22e>serviceErrorHandler</span>(<span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>serviceErr</span>, <span style=color:#a6e22e>request</span>, <span style=color:#a6e22e>response</span>)
	})

	<span style=color:#a6e22e>director</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>director</span>{
		<span style=color:#a6e22e>name</span>:               <span style=color:#a6e22e>name</span>,
		<span style=color:#a6e22e>goRestfulContainer</span>: <span style=color:#a6e22e>gorestfulContainer</span>,
		<span style=color:#a6e22e>nonGoRestfulMux</span>:    <span style=color:#a6e22e>nonGoRestfulMux</span>,
	}

	<span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>APIServerHandler</span>{
		<span style=color:#a6e22e>FullHandlerChain</span>:   <span style=color:#a6e22e>handlerChainBuilder</span>(<span style=color:#a6e22e>director</span>),
		<span style=color:#a6e22e>GoRestfulContainer</span>: <span style=color:#a6e22e>gorestfulContainer</span>,
		<span style=color:#a6e22e>NonGoRestfulMux</span>:    <span style=color:#a6e22e>nonGoRestfulMux</span>,
		<span style=color:#a6e22e>Director</span>:           <span style=color:#a6e22e>director</span>,
	}
}
</code></pre></div><div align=center><img src=/img/kube-apiserver/server-handler-chain.png>
<center>各 server 组成的 handler 链</center></div><h2 id=8-小结>8 小结</h2><p>Kubernetes API Server 的本质是一个 HTTP Server，通过命令行参数获取用户配置，最复杂的部分是 server 的初始化。虽然最终运行起来的的只有一个 HTTP Server，kube-apiserver 实际上在业务上被拆分成三个独立的 server，形成一个单向链表，同时巧妙的将各 server 的 handler 串联起来。</p><p>HTTP Server 的最重要的部分是 hander，Kubernetes API Server 中的 handler 繁多而且业务逻辑相似，下一篇文章将详细探讨其中的实现过程。</p></div><footer><div class=stats><ul class=categories><li><a class=article-terms-link href=/categories/%e4%ba%91%e5%8e%9f%e7%94%9f/>云原生</a></li></ul><ul class=tags><li><a class=article-terms-link href=/tags/kubernetes/>kubernetes</a></li><li><a class=article-terms-link href=/tags/kube-apiserver/>kube-apiserver</a></li><li><a class=article-terms-link href=/tags/restful-go/>restful-go</a></li><li><a class=article-terms-link href=/tags/etcd/>etcd</a></li></ul></div></footer></div></article><div class=pagination></div></main><section id=site-sidebar><section id=categories><header><h1><a href=/categories>分类</a></h1></header><ul><li><a href=/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/>云原生<span class=count>1</span></a></li></ul></section><section id=mini-bio><header><h1>关于</h1></header><p>一个以计算机技术分享为主的博客，重点关注云原生、DevOps、AI 领域。除了严肃理性的分析，还会有记录生活、感悟人生的随笔。</p><footer><a href=/about class=button>详细了解</a></footer></section></section><footer id=site-footer><ul class=socnet-icons></ul><p class=copyright>© 2021 天行健 君子以自强不息<br>主题: <a href=https://themes.gohugo.io/hugo-future-imperfect-slim/ target=_blank rel=noopener>Hugo Future Imperfect Slim</a><br>移植自 <a href=https://html5up.net/future-imperfect target=_blank rel=noopener>HTML5 UP</a> | 由 <a href=https://gohugo.io/ target=_blank rel=noopener title=0.84.0>Hugo</a> 驱动</p></footer><a id=back-to-top href=# class="fas fa-arrow-up fa-2x"></a><script src=/js/highlight.js></script><script>hljs.highlightAll()</script><script src=/js/bundle.min.fdef0fe73218267b80e3555183b2561823fd4dc2784b71161088e8cf112a7bd1.js integrity="sha256-/e8P5zIYJnuA41VRg7JWGCP9TcJ4S3EWEIjozxEqe9E="></script><script src=/js/add-on.js></script></div></body></html>