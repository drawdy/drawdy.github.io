[{"title":"Kubernetes API Server 从入门到入库（上）","date":"","description":"","body":"Kubernetes API Server 负责验证和配置 Kubernetes API对象，提供了 RESTful API供用户和其他组件与 Kubernetes 交互。Kubernetes API Server 源码编译出的程序为 kube-apiserver，本质上是一个 HTTP 服务器程序，使用 go 语言提供的 http 库可以很方便的创建并运行。如下面的代码所示，监听地址（Addr）和处理方法（Handler）是创建 HTTP 服务必要的参数。\nserver := http.Server:{ Addr: addr, Handler: handler, } Addr 是 TCP 协议地址，格式为host:port。port 表示端口，值为 1~ 65535 范围内的整数，其中 1 ~ 1023 是保留端口，不可以随便使用，用户可以从 1024 ~ 65535 中选取任意一个没有被占用的数作为端口。 host 可以是 IP， 也可以是能够解析为 IP 的主机名。host 为 IP 时有三种情况：为回环地址（127.0.0.1）时，只能在本地通过 127.0.0.1 加端口访问服务；为 0.0.0.0 或者直接省略 host 只保留:port时，表示监听本机的所有 IP，从网络可达的其他主机上通过任何本机 IP加端口都可以访问服务；最常见的是指定为某个固定的 IP，如 192.168.1.10，表示可以通过该 IP 加端口访问到服务。\nHandler 是 HTTP 服务器程序的核心，是处理请求、返回响应的过程。HTTP 服务器通常会对多个路径提供服务，每个路径都对应一个 Handler，最外层的 Handler 通常称为路由器，负责解析请求消息，找到并调用路径对应的 Handler。\nKubernetes 发展速度非常快，目前的代码量已经有四五百万行，作为 Kubernetes 的入口，kube-apiserver 几乎涉及每个功能，完全理解需要对 Kubernetes 的相关概念很熟悉。另外，为了获得更好的高扩展性、低耦合度、高代码复用率，社区开发人员应用大量框架优化架构，这导致阅读源码不太容易。本文结合源码对 Kubernetes API Server 运行流程、架构原理加以说明，希望对你有所帮助。\n1 启动过程 阅读源码最好先从最外层方法看起，遇到调用的子方法，先大概了解子方法的功能作用，不宜最开始就深入到最内层，等外层方法的过程明白了主要功能作用，再进入到子方法看细节。kube-apiserver 程序入口在 Kubernetes 代码仓库cmd/kube-apiserver/apiserver.go文件。如下图所示，从整体上看，kube-apiserver 的启动过程包括了解析命令行参数、创建服务配置、创建聚合服务器、启动服务器几个步骤，其中创建聚合服务器最为复杂，包括创建扩展资源服务、配置 Handler、创建聚合 API 服务器等步骤，每个步骤深入进去会发现调用了很多子方法。下面就具体看下过程中重要步骤的细节。\nkube-apiserver 启动过程  2 解析命令行参数 kube-apiserver 最外层是使用 cobra 框架创建的 CLI 程序，从命令行接收参数，供后续创建服务器时使用。cmd/kube-apiserver/app/server.go文件中的 NewAPIServerCommand() 方法是创建 cobra.Command 的过程。cobra.Command 中的 Run 或 RunE 属性是命令行执行时调用的方法，其调用的 options.NewServerRunOptions() 子方法初始化主要的命令行参数，这些参数可以配置服务器、Etcd、Audit、Admission 等模块。这部分代码比较简单直观，不展开讲。\n3 创建服务配置 kube-apiserver 中的 Server 创建过程遵循统一的模式，即先初始化配置，再通过配置实例化 Server 对象。在初始化命令行参数后，程序调用 CreateServerChain() 子方法实例化服务器对象，进入到该子方法可以看到其调用 CreateKubeAPIServerConfig() 方法来初始化配置。方法返回的配置是 kube-apiserver 的基础通用配置，后续过程会在此基础上补充新的配置，以创建其他业务对象。\n服务配置覆盖的内容非常多，有些不太常用的条目,我也不确定具体作用，现对常用到配置项做出说明，以帮助理解。\ngenericConfig 通用配置，包含了很多方面的内容，像认证鉴权方法、CORS 源、准入控制、是否开启路径索引、是否开启服务启动后回调钩子等，还有一部分内容主要服务于程序后续流程，跟用户自定义关系不大，如序列化组件、健康检测器、构建 handler 链的方法等。\nversionedInformers 内置资源的 Informer，优化外部通过 kube-apiserver 操作资源的操作。Informer 可以理解为客户端请求 API 资源过程中的优化组件，使用内存队列缓存客户端监听的资源，有着优秀的架构设计，对 kube-apiserver 启动过程影响不大，本文不做过多说明。\nserviceResolver 可以将对服务的请求转化为具体的 URL，即解析为服务对应的 Endpoint。\npluginInitializers 服务于准入控制（admission）模块，准入控制插件会实现对应的接口以表达自己需要被注入的依赖数据，pluginInitializers 负责检测插件实现了哪些接口并注入相应的数据。\nadmissionPostStartHook 准入控制执行完后的回调钩子。\nstorageFactory 是创建 API 资源存储接口的组件。Kubernetes 的所有数据都存储在 Etcd 中，各 API 资源的存储逻辑是相似的。storageFactory 中包括了 Etcd 相关属性，默认的序列化器、API 资源组路径前缀等。\ncapabilities 是对操作系统支撑能力的表示，如特权模式相关配置等。\n4 三种类型的 API Server 从 CreateServerChain() 这个方法名可以看出，程序创建的是包含多个server的服务器链，准确的说是三个，即 APIExtentionsServer、KubeAPIServer 和 AggregatorServer。APIExtentionsServer 用于管理自定义资源等扩展 API，定义了处理 CustomResourceDefinition 对象的 handler。KubeAPIServer 用于管理内置资源，包括传统资源（LegacyAPI，如 Pod、Service、ConfigMap）和常规资源（路径前缀为 /apis，如 Deployment、StorageClass、ClusterRole）,传统资源是 Kubernetes 早期创建的内置资源，没有隶属的组（Group），路径前缀为/api。AggregatorServer 则是一种特殊类型的 API Server，相对于安装集群时部署 kube-apiserver 组件，这里的 API Server 的含义已经发生了变化，是之逻辑上自成一体的服务模块，这样的服务可以有很多个，像上面的 APIExtentionsServer 和 KubeAPIServer 都是这种概念，这些服务在 Kuberenetes中被描述成 APIService 资源。 AggregatorServer 创建控制器自动收集集群中的 APIService 资源，自动注册到反向代理服务器，用户独立开发的 API Server 通过这种方式集成到 Kubernetes，不用将代码合并到主库。\n实际上，这三个 Server 只是逻辑上的划分，各自有业务上相对独立的 Handler，区别开来可以更好的封装和解耦，最终创建出来的 HTTP Server 只有一个。那么这些 Server 是怎么关联起来的呢？观察三个 Server 的创建方法，会发现每个都有一个 DelegationTarget 参数，新创建的的 Server 会将该参数作为属性引用。其实，DelegationTarget 是对 API Server 的抽象，如果当前 Server 无法处理请求就委托给关联的 DelegationTarget 处理。这些 Server 在结构上组成一个单向链表，每个 Server 都是其中的节点，如下图所示。\nkube-apiserver 服务链  5 启动服务器 如下面的代码所示，在创建完 server 链后，程序执行 server.PrepareRun() 方法做准备工作，主要有两部分内容，一是注册 readyz、livez 等状态检测 API，还有是注册启动后、退出前的回调方法。PrepareRun 会以递归的方式调用 API Server 链上每个 Server 的 PrepareRun 方法。\nfunc Run(completeOptions completedServerRunOptions, stopCh \u0026lt;-chan struct{}) error { // To help debugging, immediately log version \tklog.Infof(\u0026#34;Version: %+v\u0026#34;, version.Get()) server, err := CreateServerChain(completeOptions, stopCh) if err != nil { return err } prepared, err := server.PrepareRun() if err != nil { return err } return prepared.Run(stopCh) } 准备工作完成后，服务开始启动，最终会调用 Golang 的库方法 http.server.Serve() 启动 HTTP 服务。\n6 go-restful 框架 kube-apiserver 使用 go-restful 框架配置 Handler，该框架有三个核心概念：\nRoute 表示一条路由，包含请求路径、请求方法及对应的 Handler，框架内置的路由选择器根据 Route 配置将客户端的请求路由到相应的 Handler 进行处理；\nWebService 表示一组 API 集合，由多个 Route 组成。WebService 中的 Route 具有相同的 root path，一致的请求数据类型，一般是相关性非常强的 API。\nContainer 表示一个服务器，由多个 WebService 组成，包含一个 dispatch 方法，负责将 Container 接收的请求分发给持有的 WebService，再由 WebService 分发给具体的 Handler。\n在使用框架时，开发人员需要创建 Container 实例，并添加 WebService 和 Route，再提交给 http.Server 作为 Handler 使用。Container 其实就是最外层的 HTTP 请求处理方法。上述三者的关系如下图所示。\nRoute、WebService 和 Container 关系  7 各server handler 联系 上一节中说到，三个 API Server 组成一个链表，后创建的 Server 引用前一个，DelegationTarget 作为 Server 的抽象接口被持有。如下面的代码所示， Server 在创建时会将 DelegationTarget.UnprotectedHandler() 即持有的上一个 Server 的 Handler 作为 notFoundHandler 添加到当前 Server 的Container。这样达到的效果是，当前 Server 匹配不到的请求路径时会交由持有的上一个 Server 处理，三个 Server 的 Handler 也形成了链表的关系。\nfunc NewAPIServerHandler(name string, s runtime.NegotiatedSerializer, handlerChainBuilder HandlerChainBuilderFn, notFoundHandler http.Handler) *APIServerHandler { nonGoRestfulMux := mux.NewPathRecorderMux(name) if notFoundHandler != nil { nonGoRestfulMux.NotFoundHandler(notFoundHandler) } gorestfulContainer := restful.NewContainer() gorestfulContainer.ServeMux = http.NewServeMux() gorestfulContainer.Router(restful.CurlyRouter{}) gorestfulContainer.RecoverHandler(func(panicReason interface{}, httpWriter http.ResponseWriter) { logStackOnRecover(s, panicReason, httpWriter) }) gorestfulContainer.ServiceErrorHandler(func(serviceErr restful.ServiceError, request *restful.Request, response *restful.Response) { serviceErrorHandler(s, serviceErr, request, response) }) director := director{ name: name, goRestfulContainer: gorestfulContainer, nonGoRestfulMux: nonGoRestfulMux, } return \u0026amp;APIServerHandler{ FullHandlerChain: handlerChainBuilder(director), GoRestfulContainer: gorestfulContainer, NonGoRestfulMux: nonGoRestfulMux, Director: director, } } 各 server 组成的 handler 链  8 小结 Kubernetes API Server 的本质是一个 HTTP Server，通过命令行参数获取用户配置，最复杂的部分是 server 的初始化。虽然最终运行起来的的只有一个 HTTP Server，kube-apiserver 实际上在业务上被拆分成三个独立的 server，形成一个单向链表，同时巧妙的将各 server 的 handler 串联起来。\nHTTP Server 的最重要的部分是 hander，Kubernetes API Server 中的 handler 繁多而且业务逻辑相似，下一篇文章将详细探讨其中的实现过程。\n","ref":"/blog/kube-apiserver-1/"},{"title":"关于本站","date":"","description":"","body":"技术成长的道路并非都是坦途，此刻的我正面临挑战，想要突破就必须深入思考，穷究至理，不断探索，拓展眼界，当然更少不了大量有难度的编码练习。因此，我创建此 Blog，记录这一过程。\n“采珠人”这个网站名字是取自一本计算机科学的经典名著。聪明的你肯定已经猜到了，没错，这本书正是《编程珠玑》。在书的前言，作者写到：“本书描述了计算机编程更具魅力的一面：在可靠的工程之外，在洞察力和创造力范围内结晶而出的编程珠玑。”。作者将编程技术的真谛和本质比喻为珍珠，我想，这大概就是厉害的计算机技术人应该达到的境界。我希望成为这样拥有“珍珠”的人。\n本网站是个人建立的以计算机技术分享为主的博客，重点关注云原生、DevOps、AI 领域。除了严肃理性的分析，还会有记录生活、感悟人生的随笔。\n","ref":"/about/"}]